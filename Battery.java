/**
 * This class defines a {@code Battery} object which can be only used
 * to store electricity. If the units consumed by the {@link BatteryMeter}
 * meter over a time increment is negative (i.e. production has exceeded
 * the consumption of the other appliances), the excess units get stored in
 * the battery. In the next time increment, if consumption exceeds production,
 * the battery is used to power the house decreasing the units consumed
 * by {@link BatteryMeter}.
 *
 *
 */
public class Battery {
	
    private float batteryCapacity;
    private float batteryUnits;

    /**
     * Creates a new {@code Battery} object.
     * @param batteryCapacity the capacity of the battery.
     */
    public Battery(float batteryCapacity){
        this.batteryCapacity = batteryCapacity;
        this.batteryUnits = 0;
    }

    /**
     * Returns the max number of units that can be stored in the battery
     * @return the battery capacity
     */
    public float getBatteryCapacity() {
        return batteryCapacity;
    }

    /**
     * Returns the number of slots available to store units
     * @return the slots available
     */
    public float getSlots(){
        return this.batteryCapacity - this.batteryUnits;
    }

    /**
     * Returns the current amount of units previously stored in the battery.
     * @return the units in the battery
     */
    public float getBatteryUnits() {
        return batteryUnits;
    }


    /**
     * Stores the number of {@code units} generated by other appliances.
     * {@code units} are stored depending on the current {@link #getSlots()}
     * available, and there are two different cases:
     *
     *      1. All {@code units} can be stored in {@code Battery}.
     *      2. Some {@code units} are wasted and some are stored.
     *
     * @param units         the units generated by other appliances.
     * @return unitsStored  units stored to the battery
     */
    public float storeUnits(float units){

        float unitsStored = Math.abs(units);

        // First case
        if(getSlots() >= unitsStored){
            batteryUnits += unitsStored;

        }
        // Second case
        else {
            float unitsWasted = unitsStored - getSlots();
            unitsStored = unitsStored - unitsWasted;
            batteryUnits += unitsStored;
        }

        return  unitsStored;
    }

    /**
     * Takes the number of {@code units} needed to cover the consumption of other appliances.
     *
     * The {@code units} are taken depending on the current {@link #getBatteryUnits()}
     * available, and there are two different cases:
     *
     *      1. The consumption can be fully covered by taking the same number of {@param units}.
     *      2. The consumption can be partially covered by taking {@link #getBatteryUnits()} available.
     *
     * @param  units        units to take
     * @return unitsTaken   units taken from the battery
     */
    public float takeUnits(float units){
        float unitsTaken = units;

        // Case 1:
        if(batteryUnits < unitsTaken){
            unitsTaken = batteryUnits; //Max number of units possibile to take
            batteryUnits -= unitsTaken; //Updated the units in the battery
        }

        // Case 2:
        else{
            batteryUnits -= unitsTaken;
        }

        return unitsTaken;
    }
}
